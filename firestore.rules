/**
 * @file Firebase Security Rules for the Student Marketplace.
 *
 * @Core Philosophy:
 * This ruleset prioritizes a secure, user-centric data model where users primarily access their own data or participate in shared resources.
 * It leverages denormalization and structural segregation to enforce access control efficiently. Data validation is relaxed for prototyping,
 * focusing on authorization and relational integrity.
 *
 * @Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - Listings are stored under `/listings/{listingId}`, with sellerId for ownership.
 * - Chats are stored under `/chats/{chatId}`, with participants array defining access.
 * - Messages are stored under `/chats/{chatId}/messages/{messageId}`.
 * - Reviews are stored under `/reviews/{reviewId}`, with sellerId and buyerId for access control.
 * - Events are stored under `/events/{eventId}`, with organizerId for ownership.
 * - Community feed posts are stored under `/community_feed/{postId}`, with authorId for ownership.
 * - Reports are stored under `/reports/{reportId}`.
 * - Transactions are stored under `/transactions/{transactionId}`, with buyerId, sellerId, and listingId for context.
 * - Admin roles are stored under `/roles_admin/{userId}` as existence-based flags.
 *
 * @Key Security Decisions:
 * - User listing is generally disallowed to protect privacy.
 * - Public read access is granted for collections intended for public consumption (e.g., community feed), with ownership enforced for writes.
 * - Ownership is strictly enforced for user-specific data and actions.
 * - Roles are managed using existence checks in a dedicated collection.
 * - Data validation is minimized to essential checks for authorization and relational integrity.
 *
 * @Denormalization for Authorization:
 * - Listings include `sellerId` to allow ownership checks without extra reads.
 * - Chats include a `participants` array to define authorized users.
 * - Reviews include `sellerId` and `buyerId` for access control.
 * - Events include `organizerId` for ownership checks.
 * - Community Feed includes `authorId` for ownership checks.
 * - Transactions include `buyerId` and `sellerId` to avoid `get()` calls.
 *
 * @Structural Segregation:
 * - Admin roles are stored in a separate `/roles_admin/{userId}` collection.
 * - User data is separated from public content.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profiles. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (read, write) if request.auth.uid == userId
     * @deny (read, write) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is generally disallowed for privacy.
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isOwner(userId) && resource.data.uid == userId;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Manages listings. Allows public read access, but restricts writes to the seller.
     * @path /listings/{listingId}
     * @allow (read) any authenticated user
     * @allow (create, update, delete) only the seller with matching sellerId
     * @deny (create, update, delete) if request.auth.uid != resource.data.sellerId
     * @principle Public read with owner-only writes, enforcing document ownership for writes.
     */
    match /listings/{listingId} {
      function isOwner(sellerId) {
        return request.auth != null && request.auth.uid == sellerId;
      }

      allow get, list: if true;
      allow create: if isOwner(request.resource.data.sellerId) && request.resource.data.sellerId == request.auth.uid;
      allow update: if isOwner(resource.data.sellerId) && resource != null;
      allow delete: if isOwner(resource.data.sellerId) && resource != null;
    }

    /**
     * @description Manages chats. Only participants can read/write.
     * @path /chats/{chatId}
     * @allow (read, write) only if the user is a participant in the chat.
     * @deny (read, write) if the user is not a participant.
     * @principle Shared Access (Closed Collaborators), ensuring that only members of the chat can access it.
     */
    match /chats/{chatId} {
      function isParticipant() {
        return request.auth != null && request.resource.data.participants.hasAny([request.auth.uid]);
      }
      function isExistingParticipant() {
          return request.auth != null && resource.data.participants.hasAny([request.auth.uid]);
      }

      allow get: if isExistingParticipant();
      allow list: if false; // Listing chats is generally disallowed for privacy.
      allow create: if isParticipant();
      allow update: if isExistingParticipant() && resource != null;
      allow delete: if false; // Deleting a chat is not allowed.
    }

    /**
     * @description Manages messages within a chat. Only participants of the chat can read/write messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (read, write) only if the user is a participant in the parent chat.
     * @deny (read, write) if the user is not a participant in the parent chat.
     * @principle Shared Access (Closed Collaborators), inheriting access control from the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
        function isChatParticipant(chatId) {
            return exists(/databases/$(database)/documents/chats/$(chatId))
                   && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        }

        allow get: if isChatParticipant(chatId);
        allow list: if isChatParticipant(chatId);
        allow create: if isChatParticipant(chatId);
        allow update: if false; // Messages cannot be updated.
        allow delete: if false; // Messages cannot be deleted.
    }

    /**
     * @description Manages reviews. Only the buyer and seller can read, only the buyer can create.
     * @path /reviews/{reviewId}
     * @allow (read) only the buyer or seller involved in the review.
     * @allow (create) only the buyer creating the review.
     * @deny (update, delete) no one can update or delete reviews.
     * @principle Enforces access control based on the buyer and seller relationship.
     */
    match /reviews/{reviewId} {
      function isBuyer(buyerId) {
        return request.auth != null && request.auth.uid == buyerId;
      }
      function isSeller(sellerId) {
          return request.auth != null && request.auth.uid == sellerId;
      }
      allow get: if isBuyer(resource.data.buyerId) || isSeller(resource.data.sellerId);
      allow list: if false; // Listing reviews is generally disallowed for privacy.
      allow create: if isBuyer(request.resource.data.buyerId) && request.resource.data.buyerId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages events. Allows public read access, restricts writes to the organizer.
     * @path /events/{eventId}
     * @allow (read) any authenticated user
     * @allow (create, update, delete) only the organizer of the event.
     * @principle Public read with owner-only writes, enforcing document ownership for writes.
     */
    match /events/{eventId} {
      function isOrganizer(organizerId) {
        return request.auth != null && request.auth.uid == organizerId;
      }

      allow get, list: if true;
      allow create: if isOrganizer(request.resource.data.organizerId) && request.resource.data.organizerId == request.auth.uid;
      allow update: if isOrganizer(resource.data.organizerId) && resource != null;
      allow delete: if isOrganizer(resource.data.organizerId) && resource != null;
    }

    /**
     * @description Manages community feed posts. Allows public read access, restricts writes to the author.
     * @path /community_feed/{postId}
     * @allow (read) any authenticated user
     * @allow (create, update, delete) only the author of the post.
     * @principle Public read with owner-only writes, enforcing document ownership for writes.
     */
    match /community_feed/{postId} {
      function isAuthor(authorId) {
        return request.auth != null && request.auth.uid == authorId;
      }

      allow get, list: if true;
      allow create: if isAuthor(request.resource.data.authorId) && request.resource.data.authorId == request.auth.uid;
      allow update: if isAuthor(resource.data.authorId) && resource != null;
      allow delete: if isAuthor(resource.data.authorId) && resource != null;
    }

    /**
     * @description Manages reports.  No write permissions are allowed from the client.
     * @path /reports/{reportId}
     * @allow (read) nobody.
     * @allow (write) nobody.
     * @principle Restricts access to reports.
     */
    match /reports/{reportId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages transactions. Only the buyer or seller can read.
     * @path /transactions/{transactionId}
     * @allow (read) only the buyer or seller involved in the transaction.
     * @allow (write) nobody.
     * @principle Enforces access control based on the buyer and seller relationship.
     */
    match /transactions/{transactionId} {
      function isBuyer(buyerId) {
        return request.auth != null && request.auth.uid == buyerId;
      }
      function isSeller(sellerId) {
          return request.auth != null && request.auth.uid == sellerId;
      }

      allow get: if isBuyer(resource.data.buyerId) || isSeller(resource.data.sellerId);
      allow list: if false; // Listing transactions is generally disallowed for privacy.
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

       /**
        * @description Manages admin roles. The existence of a document with the user's ID grants admin privileges.
        * @path /roles_admin/{userId}
        * @allow (read) only admins.
        * @allow (create) only the user themselves, to flag themselves as admins. This requires manual server intervention to delete.
        *
        * @principle Global Roles managed via existence checks.
        */
        match /roles_admin/{userId} {
            function isAdmin() {
              return request.auth != null && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
            }
            allow get: if isAdmin();
            allow list: if false;
            allow create: if request.auth.uid == userId;
            allow update: if false;
            allow delete: if false;
        }
  }
}