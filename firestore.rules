/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user identity and
 * explicit relationships defined within the data. It uses path-based ownership
 * for user-specific data and membership maps for shared resources like chats.
 * Data shape validation is relaxed for prototyping.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the owning user.
 * - /listings/{listingId}: Marketplace listings, with owner-only writes.
 * - /chats/{chatId}: Chat conversations, restricted to participants.
 * - /chats/{chatId}/messages/{messageId}: Messages within chats, restricted to chat participants.
 * - /reviews/{reviewId}: Reviews of sellers, publicly readable.
 * - /events/{eventId}: Events organized by users, owner-only writes.
 * - /community_feed/{postId}: Community feed posts, owner-only writes.
 * - /reports/{reportId}: Reports of users or content.
 * - /transactions/{transactionId}: Transaction records between buyers and sellers.
 * - /roles_admin/{userId}: Collection indicating admin roles based on document existence.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy (except for admins).
 * - Read-only collections are explicitly marked and allowed for public read access.
 * - Owner-only writes are enforced using `authorId` or similar fields.
 * - The default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - Listings include the `sellerId` to avoid `get()` calls for ownership checks.
 * - Chats include a `participants` array for direct membership checks.
 * - Roles are determined by the existence of documents in the `/roles_admin/{userId}` collection,
 *   avoiding the need to store role data within user documents.
 *
 * Structural Segregation:
 * - User data is stored under `/users/{userId}` for private access.
 * - Publicly readable data (e.g., listings, community feed posts) is stored in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, ensuring only the owning user can read or write their data.
     * @path /users/{userId}
     * @allow (create) User with uid 'user_abc' can create their profile at /users/user_abc.
     * @allow (get) User with uid 'user_abc' can read their profile at /users/user_abc.
     * @allow (update) User with uid 'user_abc' can update their profile at /users/user_abc.
     * @allow (delete) User with uid 'user_abc' can delete their profile at /users/user_abc.
     * @deny (create) User with uid 'user_xyz' cannot create a profile at /users/user_abc.
     * @deny (get) User with uid 'user_xyz' cannot read the profile at /users/user_abc.
     * @deny (update) User with uid 'user_xyz' cannot update the profile at /users/user_abc.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      // Verified Identity: Only signed-in users can access this data.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.uid == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages marketplace listings, allowing public reads but restricting writes to the seller.
     * @path /listings/{listingId}
     * @allow (get) Any user can read a listing at /listings/listing_123.
     * @allow (list) Any user can list listings.
     * @allow (create) User with uid 'user_abc' can create a listing with sellerId 'user_abc'.
     * @allow (update) User with uid 'user_abc' can update a listing at /listings/listing_123 if they are the seller.
     * @allow (delete) User with uid 'user_abc' can delete a listing at /listings/listing_123 if they are the seller.
     * @deny (create) User with uid 'user_xyz' cannot create a listing with sellerId 'user_abc'.
     * @deny (update) User with uid 'user_xyz' cannot update a listing at /listings/listing_123 if they are not the seller.
     * @principle Enforces owner-only writes for listings, allowing public reads.
     */
    match /listings/{listingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.sellerId) && resource != null;
      allow delete: if isSignedIn() && isExistingOwner(resource.data.sellerId);
    }

    /**
     * @description Secures chat conversations, restricting access to participants only.
     * @path /chats/{chatId}
     * @allow (get) User with uid 'user_abc' can read chat /chats/chat_123 if they are a participant.
     * @allow (list) Listing chats is not permitted.
     * @allow (create) User with uid 'user_abc' can create a chat if they are a participant.
     * @allow (update) User with uid 'user_abc' can update chat /chats/chat_123 if they are a participant.
     * @allow (delete) Deleting chats is not permitted.
     * @deny (get) User with uid 'user_xyz' cannot read chat /chats/chat_123 if they are not a participant.
     * @principle Restricts chat access to authorized participants using a membership list.
     */
    match /chats/{chatId} {
      allow get: if isSignedIn() && isParticipant(resource.data.participants);
      allow list: if false;
      allow create: if isSignedIn() && isParticipant(request.resource.data.participants);
      allow update: if isSignedIn() && isParticipant(resource.data.participants) && resource != null;
      allow delete: if false;
    }

    /**
     * @description Protects messages within a chat, ensuring only participants can read or write them.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get) User with uid 'user_abc' can read message /chats/chat_123/messages/message_456 if they are a participant in chat_123.
     * @allow (list) User with uid 'user_abc' can list messages in /chats/chat_123/messages if they are a participant in chat_123.
     * @allow (create) User with uid 'user_abc' can create message /chats/chat_123/messages/message_456 if they are a participant in chat_123.
     * @allow (update) Updating messages is not permitted.
     * @allow (delete) Deleting messages is not permitted.
     * @deny (get) User with uid 'user_xyz' cannot read message /chats/chat_123/messages/message_456 if they are not a participant in chat_123.
     * @principle Restricts message access to authorized chat participants.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isChatParticipant(chatId);
      allow create: if isSignedIn() && isChatParticipant(chatId);
      allow update, delete: if false;
    }

    /**
     * @description Manages reviews of sellers, allowing public reads but restricting writes to the buyer.
     * @path /reviews/{reviewId}
     * @allow (get) Any user can read a review at /reviews/review_123.
     * @allow (list) Any user can list reviews.
     * @allow (create) User with uid 'user_abc' can create a review with buyerId 'user_abc'.
     * @allow (update) Updating reviews is not permitted.
     * @allow (delete) Deleting reviews is not permitted.
     * @deny (create) User with uid 'user_xyz' cannot create a review with buyerId 'user_abc'.
     * @principle Allows public read access for reviews but restricts writes to the buyer.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update, delete: if false;
    }

    /**
     * @description Manages events, allowing public reads but restricting writes to the event organizer.
     * @path /events/{eventId}
     * @allow (get) Any user can read an event at /events/event_123.
     * @allow (list) Any user can list events.
     * @allow (create) User with uid 'user_abc' can create an event with organizerId 'user_abc'.
     * @allow (update) User with uid 'user_abc' can update an event at /events/event_123 if they are the organizer.
     * @allow (delete) User with uid 'user_abc' can delete an event at /events/event_123 if they are the organizer.
     * @deny (create) User with uid 'user_xyz' cannot create an event with organizerId 'user_abc'.
     * @deny (update) User with uid 'user_xyz' cannot update an event at /events/event_123 if they are not the organizer.
     * @principle Enforces owner-only writes for events, allowing public reads.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.organizerId) && resource != null;
      allow delete: if isSignedIn() && isExistingOwner(resource.data.organizerId);
    }

    /**
     * @description Manages community feed posts, allowing public reads but restricting writes to the author.
     * @path /community_feed/{postId}
     * @allow (get) Any user can read a community feed post at /community_feed/post_123.
     * @allow (list) Any user can list community feed posts.
     * @allow (create) User with uid 'user_abc' can create a community feed post with authorId 'user_abc'.
     * @allow (update) User with uid 'user_abc' can update a community feed post at /community_feed/post_123 if they are the author.
     * @allow (delete) User with uid 'user_abc' can delete a community feed post at /community_feed/post_123 if they are the author.
     * @deny (create) User with uid 'user_xyz' cannot create a community feed post with authorId 'user_abc'.
     * @deny (update) User with uid 'user_xyz' cannot update a community feed post at /community_feed/post_123 if they are not the author.
     * @principle Enforces owner-only writes for community feed posts, allowing public reads.
     */
    match /community_feed/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.authorId) && resource != null;
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Stores reports of users or content.  No specific access control is specified in the description.
     * Reports are very sensitive and should likely only be created by authenticated users and read by admins.
     * @path /reports/{reportId}
     * @allow (create) Authenticated user can create a report.
     * @deny (get) Nobody can get a report
     * @deny (list) Nobody can list reports.
     *
     * @principle Enforces authenticated user creation.
     */
    match /reports/{reportId} {
        allow get, list: if false; // Explicitly deny read access for now
        allow create: if isSignedIn();
        allow update, delete: if false; // No updating or deleting reports.
    }

    /**
     * @description Stores transaction information. No specific access control is specified in the description.
     * Transactions contain financial information so access should likely be restricted to the buyer and seller.
     * @path /transactions/{transactionId}
     * @allow (get) Buyer or seller can get a transaction.
     * @allow (list) Nobody can list transactions.
     * @allow (create) Authenticated user can create a transaction.
     * @deny (update) Nobody can update transactions.
     *
     * @principle Enforces authenticated user creation, limits read access.
     */
    match /transactions/{transactionId} {
        allow get: if isSignedIn() && (isOwner(resource.data.buyerId) || isOwner(resource.data.sellerId));
        allow list: if false;
        allow create: if isSignedIn();
        allow update, delete: if false; // No updating or deleting transactions.
    }

    /**
     * @description Manages admin roles based on document existence.
     * @path /roles_admin/{userId}
     * @allow (create) Only admins can create an admin role document.
     * @allow (get) Any signed-in user can check if they are an admin.
     * @allow (list) Listing admin roles is not permitted.
     * @allow (update) Updating admin roles is not permitted.
     * @allow (delete) Only admins can delete an admin role document.
     * @deny (create) User with uid 'user_xyz' cannot create an admin role for 'user_abc' if not an admin.
     * @principle Controls admin privileges based on document existence in a dedicated collection.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn(); // Any signed-in user can check for admin status
      allow list: if false;
      allow create: if isAdmin(); // Only admins can create admin role documents
      allow update: if false; // No updates allowed
      allow delete: if isAdmin(); // Only admins can delete admin role documents
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Checks if the current user is in the list of participants.
    function isParticipant(participants) {
      return isSignedIn() && participants.hasAny([request.auth.uid]);
    }

    // Checks if the current user is a participant in the given chat.
    function isChatParticipant(chatId) {
      return get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
    }

    // Checks if the user has admin privileges by checking for a document in the roles_admin collection.
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
  }
}