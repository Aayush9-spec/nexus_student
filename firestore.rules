/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model, blending user-based access control with resource-based access control.
 * It prioritizes secure data ownership and restricts unauthorized access to user-specific data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible for reading by authenticated users and writable only by the owner (the user with the matching UID).
 * - /listings/{listingId}: Stores marketplace listings, with read access open to all and write access restricted to the owner (seller).
 * - /chats/{chatId}: Stores chat conversations, accessible to participating users only.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within chat, access controlled by chat membership.
 * - /reviews/{reviewId}: Stores reviews, access restricted based on buyer and seller relationships.
 * - /events/{eventId}: Stores events, write access restricted to the organizer (event creator).
 * - /community_feed/{postId}: Stores community feed posts, with write access restricted to the author.
 * - /reports/{reportId}: Stores reports of users or content. Access is restricted.
 * - /transactions/{transactionId}: Stores transaction information, access is restricted.
 * - /roles_admin/{userId}: Collection for managing admin roles; document existence grants admin privileges.
 *
 * Key Security Decisions:
 * - Authenticated users can list and read data from the `/users` collection, but only write to their own document.
 * - Unauthenticated users cannot list or read from the `/users` collection.
 * - Other collections are locked down and require authentication for access.
 * - Schema validation is relaxed to allow for rapid prototyping. Only authorization-critical fields are validated.
 * - Destructive operations (update, delete) require verification of document existence.
 *
 * Denormalization for Authorization:
 * - Listings store the `sellerId` directly, enabling ownership checks without additional reads.
 * - Chats store a `participants` array, simplifying access control for chat conversations.
 * - Reviews store both `sellerId` and `buyerId`, allowing for clear validation of the reviewer-reviewee relationship.
 * - Events store `organizerId`, enabling clear creator ownership checks.
 * - CommunityFeed stores `authorId` to validate ownership.
 * - Transactions store `buyerId` and `sellerId`, enabling validation of involved users.
 *
 * Structural Segregation:
 * - User profiles and admin roles are stored in separate collections to simplify access management.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows authenticated users to read user profiles, and each user can only write to their own user document. Unauthenticated users cannot list or read.
     * @path /users/{userId}
     * @allow (get, list) - Authenticated user reads a user profile.
     *    auth.uid: "user123"
     * @allow (create, update, delete) - User updates their own profile.
     *    auth.uid: "user123", request.resource.data.uid: "user123"
     * @deny (get, list) - Unauthenticated user tries to read user profiles.
     *    auth.uid: null
     * @deny (create, update, delete) - User tries to update another user's profile.
     *    auth.uid: "user456", request.resource.data.uid: "user123"
     * @principle Enforces user-based access control for profile data.
     */
    match /users/{userId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read listings, but only the owner can create, update, or delete them.
     * @path /listings/{listingId}
     * @allow (get, list) - Any user reads listing.
     *    auth.uid: null
     * @allow (create) - User creates a new listing with correct ownership.
     *    auth.uid: "user123", request.resource.data.sellerId: "user123"
     * @allow (update, delete) - User updates/deletes their own listing.
     *    auth.uid: "user123", resource.data.sellerId: "user123"
     * @deny (create) - User creates listing with incorrect ownership.
     *    auth.uid: "user456", request.resource.data.sellerId: "user123"
     * @deny (update, delete) - User tries to modify another user's listing.
     *    auth.uid: "user456", resource.data.sellerId: "user123"
     * @principle Enforces public read access with owner-only writes for listings.
     */
    match /listings/{listingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.sellerId);
    }

    /**
     * @description Allows participants of a chat to read and write messages. Only participants can manage chat details.
     * @path /chats/{chatId}
     * @allow (get, list) - User who is a participant reads a chat.
     *    auth.uid: "user123", resource.data.participants: ["user123", "user456"]
     * @allow (create) - User creates a chat with themselves as a participant.
     *    auth.uid: "user123", request.resource.data.participants: ["user123", "user456"]
     * @allow (update, delete) - Owner updates or deletes the chat.
     *    auth.uid: "user123", resource.data.participants: ["user123", "user456"]
     * @deny (get, list) - User who is not a participant tries to read a chat.
     *    auth.uid: "user789", resource.data.participants: ["user123", "user456"]
     * @principle Enforces shared access for chat conversations.
     */
    match /chats/{chatId} {
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.participants;
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participants;
      allow update: if isSignedIn() && request.auth.uid in resource.data.participants;
      allow delete: if false; // Chats cannot be deleted
    }

    /**
     * @description Allows participants of a chat to manage messages within the chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) - User who is a participant in the parent chat can read the message.
     *    auth.uid: "user123", parent chat participants: ["user123", "user456"]
     * @allow (create) - User who is a participant in the parent chat can create a message.
     *    auth.uid: "user123", parent chat participants: ["user123", "user456"]
     * @allow (update, delete) - No one can update or delete messages after creation (for auditability).
     *    auth.uid: "user123", parent chat participants: ["user123", "user456"]
     * @deny (get, list) - User who is not a participant tries to read a message.
     *    auth.uid: "user789", parent chat participants: ["user123", "user456"]
     * @principle Enforces shared access for messages within a chat.
     */
    match /chats/{chatId}/messages/{messageId} {
        allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        allow update: if false; // Messages are immutable
        allow delete: if false; // Messages cannot be deleted
    }

    /**
     * @description Allows reviews to be created and read by anyone. Only the buyer can update or delete their own review.
     * @path /reviews/{reviewId}
     * @allow (get, list) - Any user reads reviews.
     *    auth.uid: null
     * @allow (create) - User can create a review for another user.
     *    auth.uid: "user123", request.resource.data.buyerId: "user123"
     * @allow (update, delete) - Buyer updates/deletes their own review.
     *    auth.uid: "user123", resource.data.buyerId: "user123"
     * @deny (create) - User tries to create a review for another user with incorrect ownership.
     *    auth.uid: "user456", request.resource.data.buyerId: "user123"
     * @deny (update, delete) - User tries to update/delete another user's review.
     *    auth.uid: "user456", resource.data.buyerId: "user123"
     * @principle Restricts write access based on the buyer-seller relationship.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.buyerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.buyerId);
    }

    /**
     * @description Allows anyone to read events, but only the organizer can manage them.
     * @path /events/{eventId}
     * @allow (get, list) - Any user reads events.
     *    auth.uid: null
     * @allow (create) - User creates a new event with correct ownership.
     *    auth.uid: "user123", request.resource.data.organizerId: "user123"
     * @allow (update, delete) - Organizer updates or deletes their own event.
     *    auth.uid: "user123", resource.data.organizerId: "user123"
     * @deny (create) - User creates listing with incorrect ownership.
     *    auth.uid: "user456", request.resource.data.organizerId: "user123"
     * @deny (update, delete) - User tries to modify another user's event.
     *    auth.uid: "user456", resource.data.organizerId: "user123"
     * @principle Enforces owner-only writes for events.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.organizerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.organizerId);
    }

    /**
     * @description Allows anyone to read community feed posts, but only the author can manage them.
     * @path /community_feed/{postId}
     * @allow (get, list) - Any user reads community feed posts.
     *    auth.uid: null
     * @allow (create) - User creates a new post with correct ownership.
     *    auth.uid: "user123", request.resource.data.authorId: "user123"
     * @allow (update, delete) - Author updates or deletes their own post.
     *    auth.uid: "user123", resource.data.authorId: "user123"
     * @deny (create) - User creates post with incorrect ownership.
     *    auth.uid: "user456", request.resource.data.authorId: "user123"
     * @deny (update, delete) - User tries to modify another user's post.
     *    auth.uid: "user456", resource.data.authorId: "user123"
     * @principle Enforces owner-only writes for community feed posts.
     */
    match /community_feed/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Reports are restricted.
     * @path /reports/{reportId}
     * @allow (get, list) - No one reads reports.
     *    auth.uid: null
     * @allow (create) - Only authenticated users can submit a report. The current user should not be reported.
     *    auth.uid: "user123", request.resource.data.reportedUserId != "user123"
     * @allow (update, delete) - No one can update or delete reports once created.
     *    auth.uid: "user123"
     * @deny (create) - User tries to submit a report for themselves.
     *    auth.uid: "user123", request.resource.data.reportedUserId: "user123"
     * @principle Restricts access to reports.
     */
    match /reports/{reportId} {
      allow get, list: if false;
      allow create: if isSignedIn() && request.resource.data.reportedUserId != request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Transactions are restricted.
     * @path /transactions/{transactionId}
     * @allow (get, list) - No one can read transactions.
     *    auth.uid: null
     * @allow (create) - Only signed in users can create a transaction
     *    auth.uid: "user123"
     * @allow (update, delete) - Transactions cannot be updated or deleted.
     *    auth.uid: "user123"
     * @principle Restricts access to transaction data.
     */
    match /transactions/{transactionId} {
      allow get, list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
    /**
     * @description Allows admins to be defined by the existence of a document with their user ID.
     * @path /roles_admin/{userId}
     * @allow (get) - Only the potentially admin user reads.
     *    auth.uid: "admin123"
     * @allow (list) - No one can list admin roles.
     *    auth.uid: null
     * @allow (create) - Only server side can create admin documents
     *    auth.uid: "admin123"
     * @allow (update) - No one updates admin roles.
     *    auth.uid: "admin123"
     * @allow (delete) - Only server side can delete admin documents
     *    auth.uid: "admin123"
     */
    match /roles_admin/{userId} {
        allow get: if isSignedIn();
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}