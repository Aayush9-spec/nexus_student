/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-based access control model. Users generally have full control over their own data, while public read access is granted where appropriate. Data validation is relaxed to allow for rapid prototyping and iteration.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores individual user profiles. `userId` MUST match the authenticated user's UID.
 * - `/listings/{listingId}`: Stores marketplace listings. Ownership is determined by the `sellerId` field within the document.
 * - `/chats/{chatId}`: Stores chat metadata. Access is controlled by the `participants` array within the document.
 * - `/chats/{chatId}/messages/{messageId}`: Stores individual chat messages. Access is inherited from the parent chat.
 * - `/reviews/{reviewId}`: Stores reviews of sellers. Both `sellerId` and `buyerId` are present for relationship integrity.
 * - `/events/{eventId}`: Stores event information. Ownership is determined by the `organizerId` field.
 * - `/community_feed/{postId}`: Stores community feed posts. Ownership is determined by the `authorId` field.
 * - `/reports/{reportId}`: Stores reports of users or content. Access is restricted.
 * - `/transactions/{transactionId}`: Stores transaction information.
 * - `/roles_admin/{userId}`: Indicates administrative privileges. Document existence signifies admin status.
 *
 * Key Security Decisions:
 * - Strict user-ownership model for user profiles and related data.
 * - Public read access for listings and community feed posts.
 * - Shared access control for chats based on the `participants` array.
 * - Administrative privileges managed through a dedicated `roles_admin` collection.
 * - List operations are generally restricted to owners for user-specific data.
 *
 * Denormalization for Authorization:
 * - Listings store the `sellerId` directly to enable owner-based access control without additional reads.
 * - Chats store the `participants` array directly to manage access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the document.
     * @param {string} userId - The user ID to compare against.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user is an admin.
     */
     function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
     }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' can create their own profile.
     *   Request: `auth.uid = 'user123', resource.data.uid = 'user123'`
     * @deny (create) - User with UID 'user456' cannot create a profile for 'user123'.
     *   Request: `auth.uid = 'user456', resource.data.uid = 'user123'`
     * @allow (get, update, delete, list) - User with UID 'user123' can read, update, and delete their profile.
     *   Request: `auth.uid = 'user123'`
     * @deny (get, update, delete, list) - User with UID 'user456' cannot read, update, or delete the profile of 'user123'.
     *   Request: `auth.uid = 'user456'`
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Client should not be able to list all users.
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid; // Enforce immutability of userId.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for marketplace listings.
     * @path /listings/{listingId}
     * @allow (get, list) - Any user (signed in or not) can read listings.
     * @allow (create) - User with UID 'user123' can create a listing with `sellerId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.sellerId = 'user123'`
     * @deny (create) - User with UID 'user456' cannot create a listing with `sellerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.sellerId = 'user123'`
     * @allow (update, delete) - User with UID 'user123' can update/delete their listing where `sellerId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.sellerId = 'user123'`
     * @deny (update, delete) - User with UID 'user456' cannot update/delete a listing where `sellerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.sellerId = 'user123'`
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /listings/{listingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.sellerId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.sellerId == request.auth.uid;
    }

    /**
     * @description Rules for chat conversations.
     * @path /chats/{chatId}
     * @allow (get, list) - User with UID 'user123' can read chat 'chatXYZ' if 'user123' is in `participants`.
     *   Request: `auth.uid = 'user123', resource.data.participants = ['user123', 'user456']`
     * @deny (get, list) - User with UID 'user789' cannot read chat 'chatXYZ' if 'user789' is not in `participants`.
     *   Request: `auth.uid = 'user789', resource.data.participants = ['user123', 'user456']`
     * @allow (create) - User with UID 'user123' can create a chat if 'user123' is in `participants`.
     *   Request: `auth.uid = 'user123', resource.data.participants = ['user123', 'user456']`
     * @deny (create) - User with UID 'user789' cannot create a chat if 'user789' is not in `participants`.
     *   Request: `auth.uid = 'user789', resource.data.participants = ['user123', 'user456']`
     * @allow (update, delete) - Not allowed. Chats are not meant to be updated or deleted.
     * @principle Enforces shared access based on the `participants` array.
     */
    match /chats/{chatId} {
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.participants;
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participants;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for messages within a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) - User with UID 'user123' can read messages in chat 'chatXYZ' if 'user123' is a participant in the chat.
     *   Request: `auth.uid = 'user123', get(/databases/(default)/documents/chats/chatXYZ).data.participants = ['user123', 'user456']`
     * @deny (get, list) - User with UID 'user789' cannot read messages in chat 'chatXYZ' if 'user789' is not a participant in the chat.
     *   Request: `auth.uid = 'user789', get(/databases/(default)/documents/chats/chatXYZ).data.participants = ['user123', 'user456']`
     * @allow (create) - User with UID 'user123' can create a message in chat 'chatXYZ' if 'user123' is a participant in the chat.
     *   Request: `auth.uid = 'user123', get(/databases/(default)/documents/chats/chatXYZ).data.participants = ['user123', 'user456'], resource.data.senderId = 'user123'`
     * @deny (create) - User with UID 'user789' cannot create a message in chat 'chatXYZ' if 'user789' is not a participant in the chat.
     *   Request: `auth.uid = 'user789', get(/databases/(default)/documents/chats/chatXYZ).data.participants = ['user123', 'user456']`
     * @allow (update, delete) - Not allowed. Messages are not meant to be updated or deleted.
     * @principle Inherits access control from the parent chat document and enforces sender ID validation on create.
     */
    match /chats/{chatId}/messages/{messageId} {
        allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
        allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Rules for reviews of sellers.
     * @path /reviews/{reviewId}
     * @allow (get, list) - Any user can read reviews.
     * @allow (create) - User with UID 'user123' can create a review.
     *   Request: `auth.uid = 'user123', resource.data.buyerId = 'user123'`
     * @deny (create) - User with UID 'user456' cannot create a review with `buyerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.buyerId = 'user123'`
     * @allow (update, delete) - User with UID 'user123' can update/delete their review where `buyerId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.buyerId = 'user123'`
     * @deny (update, delete) - User with UID 'user456' cannot update/delete a review where `buyerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.buyerId = 'user123'`
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.buyerId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.buyerId == request.auth.uid;
    }

    /**
     * @description Rules for events.
     * @path /events/{eventId}
     * @allow (get, list) - Any user can read events.
     * @allow (create) - User with UID 'user123' can create an event with `organizerId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.organizerId = 'user123'`
     * @deny (create) - User with UID 'user456' cannot create an event with `organizerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.organizerId = 'user123'`
     * @allow (update, delete) - User with UID 'user123' can update/delete their event where `organizerId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.organizerId = 'user123'`
     * @deny (update, delete) - User with UID 'user456' cannot update/delete an event where `organizerId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.organizerId = 'user123'`
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.organizerId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.organizerId == request.auth.uid;
    }

    /**
     * @description Rules for community feed posts.
     * @path /community_feed/{postId}
     * @allow (get, list) - Any user can read community feed posts.
     * @allow (create) - User with UID 'user123' can create a post with `authorId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.authorId = 'user123'`
     * @deny (create) - User with UID 'user456' cannot create a post with `authorId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.authorId = 'user123'`
     * @allow (update, delete) - User with UID 'user123' can update/delete their post where `authorId = 'user123'`.
     *   Request: `auth.uid = 'user123', resource.data.authorId = 'user123'`
     * @deny (update, delete) - User with UID 'user456' cannot update/delete a post where `authorId = 'user123'`.
     *   Request: `auth.uid = 'user456', resource.data.authorId = 'user123'`
     * @principle Allows public read access but enforces document ownership for writes.
     */
    match /community_feed/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource != null && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource != null && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Rules for reports.
     * @path /reports/{reportId}
     * @allow (get, list, create, update, delete) - Only admins can manage reports.
     * @principle Restricts access to administrators only.
     */
    match /reports/{reportId} {
      allow get, list, create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for transactions.
     * @path /transactions/{transactionId}
     * @allow (get, list, create, update, delete) - Only admins can manage transactions.
     * @principle Restricts access to administrators only.
     */
    match /transactions/{transactionId} {
      allow get, list, create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for admin roles.
     * @path /roles_admin/{userId}
     * @allow get: if isAdmin();
     * @allow list: if false; // No client-side listing of admins
     * @allow create: if isSignedIn() && request.auth.uid == userId && isAdmin(); // Only admins can assign admin roles, only to themselves.
     * @allow update: if false; // Admin roles cannot be updated after creation.
     * @allow delete: if isAdmin(); // Only admins can remove admin roles.
     * @principle Restricts role management to existing administrators.
     */
    match /roles_admin/{userId} {
        allow get: if isAdmin();
        allow list: if false; // No client-side listing of admins
        allow create: if isSignedIn() && request.auth.uid == userId && isAdmin(); // Only admins can assign admin roles, only to themselves.
        allow update: if false; // Admin roles cannot be updated after creation.
        allow delete: if isAdmin(); // Only admins can remove admin roles.
    }
  }
}