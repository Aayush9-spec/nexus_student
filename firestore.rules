/**
 * @fileoverview Firestore Security Rules for the Student Marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-centric model. Users primarily have access only to their own data. Authorization decisions are based on verified user identities and data denormalization to avoid costly `get()` operations within the rules.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles; enforces strict ownership (only the authenticated user can read/write their own profile).
 * - /listings/{listingId}: Stores marketplace listings; anyone can read, but only the seller (owner) can create, update, or delete.
 * - /chats/{chatId}: Stores chat metadata with an explicit list of `participants`; only participants can access.
 * - /chats/{chatId}/messages/{messageId}: Stores individual messages within chats; access controlled by chat participants.
 * - /reviews/{reviewId}: Stores reviews; no write access control enforced (potentially public reviews).
 * - /events/{eventId}: Stores event information; only the event organizer can modify.
 * - /community_feed/{postId}: Stores community posts; anyone can read, but only the author can modify.
 * - /reports/{reportId}: Stores reports; no write access control enforced.
 * - /transactions/{transactionId}: Stores transaction data; no write access control enforced.
 * - /roles_admin/{userId}: A collection of admin users. The existence of a document in this collection grants admin privileges.
 *
 * Key Security Decisions:
 * - Strict User Ownership: Most data is secured using an ownership model, where only the authenticated user matching the path or a designated field can modify data.
 * - Authorization Independence: Key authorization data (`sellerId` in listings, `participants` in chats, `organizerId` in events) is denormalized directly onto the documents to avoid extra reads during security checks.
 * - Admin Role: Implements a simple admin role using document existence in the `roles_admin` collection.
 * - Public Read, Owner Write for Listings and Community Posts: These collections allow public read access but restrict creation, modification, and deletion to the owner (`sellerId` or `authorId`).
 *
 * Denormalization for Authorization:
 * - The `listings` collection stores the `sellerId` directly on each listing document. This avoids needing to perform a `get()` operation to the `users` collection to check the seller's identity.
 * - The `chats` collection stores an array of `participants` directly on the document, enabling rules to quickly verify if the requesting user is part of the conversation.
 * - The `events` collection stores the `organizerId` directly on each event document to avoid needing to perform a `get()` operation to the `users` collection to check the organizer's identity.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profiles, allowing only the authenticated user to access their own data.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list) if request.auth.uid == userId
     * @deny (get, create, update, delete, list) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing users is disallowed.
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secures marketplace listings. Allows public read access but restricts creation, modification, and deletion to the seller.
     * @path /listings/{listingId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.sellerId
     * @allow (update, delete) if request.auth.uid == resource.data.sellerId
     * @deny (create) if request.auth.uid != request.resource.data.sellerId
     * @deny (update, delete) if request.auth.uid != resource.data.sellerId
     * @principle Allows public read, enforces seller ownership for writes, validates sellerId on create.
     */
    match /listings/{listingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(sellerId) {
        return isSignedIn() && request.auth.uid == sellerId;
      }

      function isExistingOwner(sellerId) {
        return isOwner(sellerId) && resource.data.sellerId == sellerId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.sellerId == request.auth.uid;
    }

    /**
     * @description Secures chat conversations, limiting access to participating users.
     * @path /chats/{chatId}
     * @allow (get, list) if request.auth.uid in resource.data.participants
     * @allow (create) if request.auth.uid in request.resource.data.participants
     * @allow (update, delete) if false
     * @deny (get, list) if !(request.auth.uid in resource.data.participants)
     * @deny (create) if !(request.auth.uid in request.resource.data.participants)
     * @principle Restricts access to chats based on participant membership.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(participants) {
        return isSignedIn() && participants.hasAny([request.auth.uid]);
      }

      allow get: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures messages within a chat, restricting access to participants of the parent chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid])
     * @allow (create) if get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid])
     * @allow (update, delete) if false
     * @deny (get, list) if !(get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]))
     * @deny (create) if !(get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]))
     * @principle Restricts access to messages based on parent chat membership.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isChatParticipant(chatId) {
        return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      }

      allow get: if isChatParticipant(chatId);
      allow list: if isChatParticipant(chatId);
      allow create: if isChatParticipant(chatId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores reviews for sellers. No write access control is enforced.
     * @path /reviews/{reviewId}
     * @allow (get, list) if true
     * @allow (create, update, delete) if true
     * @principle No write access control.
     */
    match /reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

    /**
     * @description Stores event information. Only the event organizer can modify.
     * @path /events/{eventId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.organizerId
     * @allow (update, delete) if request.auth.uid == resource.data.organizerId
     * @deny (create) if request.auth.uid != request.resource.data.organizerId
     * @deny (update, delete) if request.auth.uid != resource.data.organizerId
     * @principle Allows public read, enforces organizer ownership for writes, validates organizerId on create.
     */
    match /events/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(organizerId) {
        return isSignedIn() && request.auth.uid == organizerId;
      }

      function isExistingOwner(organizerId) {
        return isOwner(organizerId) && resource.data.organizerId == organizerId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.organizerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.organizerId == request.auth.uid;
    }

    /**
     * @description Stores community feed posts. Allows public read access but restricts creation, modification, and deletion to the author.
     * @path /community_feed/{postId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete) if request.auth.uid == resource.data.authorId
     * @deny (create) if request.auth.uid != request.resource.data.authorId
     * @deny (update, delete) if request.auth.uid != resource.data.authorId
     * @principle Allows public read, enforces author ownership for writes, validates authorId on create.
     */
    match /community_feed/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return isSignedIn() && request.auth.uid == authorId;
      }

      function isExistingOwner(authorId) {
        return isOwner(authorId) && resource.data.authorId == authorId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Stores reports of users or content. No write access control is enforced.
     * @path /reports/{reportId}
     * @allow (get, list) if true
     * @allow (create, update, delete) if true
     * @principle No write access control.
     */
    match /reports/{reportId} {
      allow get: if true;
      allow list: if true;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

    /**
     * @description Stores transaction information. No write access control is enforced.
     * @path /transactions/{transactionId}
     * @allow (get, list) if true
     * @allow (create, update, delete) if true
     * @principle No write access control.
     */
    match /transactions/{transactionId} {
      allow get: if true;
      allow list: if true;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

   /**
     * @description Collection to store admin roles. The existence of a document with the user's ID indicates admin privileges. Existence over content. Do not store any data other than the document ID, which is the user's UID.
     * @path /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
         function isSignedIn() {
            return request.auth != null;
        }

        function isAdmin() {
            return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
        }

        // Only admins can read the admin list
        allow get: if isAdmin();
        allow list: if isAdmin();

        // Only signed-in users can create an admin entry for themselves (subject to review)
        allow create: if isSignedIn() && request.auth.uid == userId;

        // Only admins can update or delete admin entries
        allow update: if false;
        allow delete: if isAdmin();
    }
  }
}