/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user identity and resource ownership.
 * It uses path-based ownership for user-specific data and explicit membership lists for shared resources.
 * Data validation is minimized for prototyping speed, focusing on authorization-critical fields.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Access is restricted to the user themselves.
 * - /listings/{listingId}: Stores marketplace listings. Accessible for reading by everyone, but create/update/delete is restricted to the seller.
 * - /chats/{chatId}: Stores chat metadata, including participants. Access is restricted to chat participants.
 * - /chats/{chatId}/messages/{messageId}: Stores individual messages within a chat. Access is restricted to chat participants.
 * - /reviews/{reviewId}: Stores reviews for sellers.
 * - /events/{eventId}: Stores event information.
 * - /community_feed/{postId}: Stores community feed posts.
 * - /reports/{reportId}: Stores reports of users or content.
 * - /transactions/{transactionId}: Stores transaction information.
 * - /roles_admin/{userId}: Stores admin roles. The existence of a document indicates admin privileges.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user document.
 * - Listings are publicly readable, but only the seller can modify them.
 * - Chats and messages are restricted to participants.
 * - The rules do not enforce strict schema validation during this prototyping phase.
 * - List operations are secured based on ownership or membership where appropriate.
 * - Admin roles are managed through the existence of documents in the `/roles_admin` collection.
 *
 * Denormalization for Authorization:
 * - Listings store the `sellerId` to allow ownership checks without additional reads.
 * - Chats store a `participants` array to avoid needing a separate membership collection.
 *
 * Structural Segregation:
 * - User profiles are stored under `/users/{userId}` to ensure private access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles. Users can only read and write their own profile.
     * @path /users/{userId}
     * @allow (read, write) if request.auth.uid == userId (User authenticates as the user whose profile is being accessed).
     * @deny (read, write) if request.auth.uid != userId (User tries to access another user's profile).
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId) && isExistingOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId) && isExistingOwner(userId);
    }

    /**
     * @description Controls access to marketplace listings. Listings are publicly readable, but only the seller can modify them.
     * @path /listings/{listingId}
     * @allow (get, list) if true (Any user can read any listing).
     * @allow (create, update, delete) if request.auth.uid == resource.data.sellerId (The user creating/updating/deleting the listing is the seller).
     * @deny (create, update, delete) if request.auth.uid != resource.data.sellerId (A user tries to modify a listing they don't own).
     * @principle Enforces public read access with owner-only writes for listings.
     */
    match /listings/{listingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwnerBySellerId(resource.data.sellerId);
      allow delete: if isSignedIn() && isExistingOwnerBySellerId(resource.data.sellerId);
    }

    /**
     * @description Controls access to chat conversations. Only participants can read and write to a chat.
     * @path /chats/{chatId}
     * @allow (read, write) if request.auth.uid in resource.data.participants (The user is a participant in the chat).
     * @deny (read, write) if request.auth.uid not in resource.data.participants (The user is not a participant in the chat).
     * @principle Enforces shared access (closed collaborators) for chats.
     */
    match /chats/{chatId} {
      allow get, list: if isSignedIn() && isParticipant(resource.data.participants);
      allow create: if isSignedIn() && request.resource.data.participants.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && isParticipant(resource.data.participants) && isExistingChat(resource.data.participants);
      allow delete: if isSignedIn() && isParticipant(resource.data.participants) && isExistingChat(resource.data.participants);
    }

    /**
     * @description Controls access to messages within a chat. Only participants of the chat can read and write messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (read, write) if request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants (The user is a participant in the parent chat).
     * @deny (read, write) if request.auth.uid not in get(/databases/$(database)/documents/chats/$(chatId)).data.participants (The user is not a participant in the parent chat).
     * @principle Enforces shared access (closed collaborators) for messages within a chat.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isChatMessageParticipant(chatId);
      allow create: if isSignedIn() && isChatMessageParticipant(chatId) && request.resource.data.chatId == chatId;
      allow update: if isSignedIn() && isChatMessageParticipant(chatId) && isExistingChatMessage(chatId);
      allow delete: if isSignedIn() && isChatMessageParticipant(chatId) && isExistingChatMessage(chatId);
    }

    /**
     * @description Controls access to reviews.
     * @path /reviews/{reviewId}
     */
    match /reviews/{reviewId} {
      allow get, list: if true; // Reviews are public
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingReview(resource.data.buyerId); //  && resource.data.buyerId == request.auth.uid;
      allow delete: if isSignedIn() && isExistingReview(resource.data.buyerId); // && resource.data.buyerId == request.auth.uid;
    }

    /**
     * @description Controls access to events.
     * @path /events/{eventId}
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingEventByOrganizerId(resource.data.organizerId);
      allow delete: if isSignedIn() && isExistingEventByOrganizerId(resource.data.organizerId);
    }

    /**
     * @description Controls access to community feed posts.
     * @path /community_feed/{postId}
     */
    match /community_feed/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingCommunityFeedByAuthorId(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingCommunityFeedByAuthorId(resource.data.authorId);
    }

    /**
     * @description Controls access to reports.
     * @path /reports/{reportId}
     */
    match /reports/{reportId} {
      allow get, list: if false; // Reports are private
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to transactions.
     * @path /transactions/{transactionId}
     */
    match /transactions/{transactionId} {
      allow get, list: if false; // Transactions are private
      allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Controls access to admin roles. Only admins can create other admins
      * @path /roles_admin/{userId}
      */
    match /roles_admin/{userId} {
        allow get: if isAdmin();
        allow list: if isAdmin();
        allow create: if isAdmin();
        allow update: if false;
        allow delete: if isAdmin();
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    function isParticipant(participants) {
      return isSignedIn() && participants.hasAny([request.auth.uid]);
    }

    function isChatMessageParticipant(chatId) {
      return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
    }

    function isExistingOwnerBySellerId(sellerId) {
      return request.auth.uid == sellerId && resource != null;
    }

    function isExistingChat(participants) {
        return isParticipant(participants) && resource != null;
    }

    function isExistingChatMessage(chatId) {
        return isChatMessageParticipant(chatId) && resource != null;
    }

    function isExistingReview(buyerId) {
        return request.auth.uid == buyerId  && resource != null;
    }

    function isExistingEventByOrganizerId(organizerId) {
        return request.auth.uid == organizerId  && resource != null;
    }

        function isExistingCommunityFeedByAuthorId(authorId) {
        return request.auth.uid == authorId  && resource != null;
    }
  }
}