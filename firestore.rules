/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user profiles and a collaborative access model for chats.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Access is restricted to the user themselves.
 * - /listings/{listingId}: Stores listings. Creators can modify, and anyone can read.
 * - /chats/{chatId}: Stores chat metadata. Access is based on explicit membership.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within chats. Access inherits from the parent chat.
 * - /reviews/{reviewId}: Stores reviews. No specific access controls are defined beyond the owner-only enforcement.
 * - /events/{eventId}: Stores events. Creators can modify, and anyone can read.
 * - /community_feed/{postId}: Stores community feed posts. Creators can modify, and anyone can read.
 * - /reports/{reportId}: Stores reports. No specific access controls are defined beyond the owner-only enforcement.
 * - /transactions/{transactionId}: Stores transactions. No specific access controls are defined beyond the owner-only enforcement.
 * - /roles_admin/{userId}: Stores admin roles. Existence of a document grants admin privileges.
 *
 * Key Security Decisions:
 * - Users can only access their own profile data.
 * - Listings, events, and community feed posts are publicly readable, but only the creator can modify them.
 * - Chats are only accessible to members.
 * - Listing is generally allowed for all collections except where it's user specific, such as /users/{userId}.
 * - Data validation is relaxed in favor of rapid prototyping but MUST be updated with proper input validation later.
 *
 * Denormalization for Authorization:
 * - Listings include the `sellerId` to allow rules to validate ownership without `get()` calls.
 * - Chats utilize a `participants` array within each document to explicitly define authorized users.
 *
 * Structural Segregation:
 * - User profiles are stored under /users/{userId}, ensuring private access.
 * - Public content (listings, events, community feed posts) is stored in top-level collections, allowing for public read access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (get, create, update, delete) if the user is the owner of the profile (userId matches request.auth.uid).
     * @deny (get) if the user is not the owner of the profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false; // Prevent listing of all user profiles.
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == request.auth.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to listings.
     * @path /listings/{listingId}
     * @allow (get, list) if true (publicly readable).
     * @allow (create) if the sellerId in the request matches the user's UID.
     * @allow (update, delete) if the user is the owner (sellerId) of the listing.
     * @deny (update, delete) if the listing does not exist.
     * @principle Allows public read access but restricts modifications to the owner.
     */
    match /listings/{listingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(sellerId) {
        return isSignedIn() && request.auth.uid == sellerId;
      }

       function isExistingOwner(listingId) {
        return isSignedIn() && request.auth.uid == resource.data.sellerId && exists(/databases/$(database)/documents/listings/$(listingId));
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.sellerId;
      allow update: if isExistingOwner(listingId) && request.auth.uid == request.resource.data.sellerId;
      allow delete: if isExistingOwner(listingId);
    }

    /**
     * @description Controls access to chats.
     * @path /chats/{chatId}
     * @allow (get, list) if the user is a participant in the chat.
     * @allow (create) if the user is a participant in the chat. The participants array must include the user's UID.
     * @allow (update, delete) if the user is a participant in the chat and is also the creator.
     * @deny (create, update, delete) if the chat does not exist.
     * @principle Restricts access to members of the chat.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
      }

      function isExistingParticipant(chatId) {
        return isSignedIn() && resource.data.participants.hasAny([request.auth.uid]) && exists(/databases/$(database)/documents/chats/$(chatId));
      }

      allow get: if isExistingParticipant(chatId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
      allow update: if isExistingParticipant(chatId) && request.resource.data.participants.hasAny([request.auth.uid]);
      allow delete: if false; // Deletion of chats is not allowed, so set as false.
    }

    /**
     * @description Controls access to messages within a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) if the user is a participant in the parent chat.
     * @allow (create) if the user is the sender of the message and a participant in the parent chat.
     * @allow (update, delete) if false. Messages cannot be updated or deleted.
     * @principle Inherits access control from the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(chatId) {
        return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      }

      allow get: if isParticipant(chatId);
      allow list: if isParticipant(chatId);
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.senderId && isParticipant(chatId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to reviews.
     * @path /reviews/{reviewId}
     * @allow (get, list) if true.
     * @allow (create) if the buyerId in the request matches the user's UID.
     * @allow (update, delete) if the user is the author (buyerId) of the review.
     * @principle Allows public read access but restricts modifications to the owner.
     */
    match /reviews/{reviewId} {
        function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(buyerId) {
        return isSignedIn() && request.auth.uid == buyerId;
      }

       function isExistingOwner(reviewId) {
        return isSignedIn() && request.auth.uid == resource.data.buyerId && exists(/databases/$(database)/documents/reviews/$(reviewId));
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.buyerId;
      allow update: if isExistingOwner(reviewId) && request.auth.uid == request.resource.data.buyerId;
      allow delete: if isExistingOwner(reviewId);
    }

    /**
     * @description Controls access to events.
     * @path /events/{eventId}
     * @allow (get, list) if true (publicly readable).
     * @allow (create) if the organizerId in the request matches the user's UID.
     * @allow (update, delete) if the user is the owner (organizerId) of the event.
     * @deny (update, delete) if the event does not exist.
     * @principle Allows public read access but restricts modifications to the owner.
     */
    match /events/{eventId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(organizerId) {
        return isSignedIn() && request.auth.uid == organizerId;
      }

       function isExistingOwner(eventId) {
        return isSignedIn() && request.auth.uid == resource.data.organizerId && exists(/databases/$(database)/documents/events/$(eventId));
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.organizerId;
      allow update: if isExistingOwner(eventId) && request.auth.uid == request.resource.data.organizerId;
      allow delete: if isExistingOwner(eventId);
    }

    /**
     * @description Controls access to community feed posts.
     * @path /community_feed/{postId}
     * @allow (get, list) if true (publicly readable).
     * @allow (create) if the authorId in the request matches the user's UID.
     * @allow (update, delete) if the user is the owner (authorId) of the post.
     * @deny (update, delete) if the post does not exist.
     * @principle Allows public read access but restricts modifications to the owner.
     */
    match /community_feed/{postId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return isSignedIn() && request.auth.uid == authorId;
      }

       function isExistingOwner(postId) {
        return isSignedIn() && request.auth.uid == resource.data.authorId && exists(/databases/$(database)/documents/community_feed/$(postId));
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.authorId;
      allow update: if isExistingOwner(postId) && request.auth.uid == request.resource.data.authorId;
      allow delete: if isExistingOwner(postId);
    }

    /**
     * @description Controls access to reports.
     * @path /reports/{reportId}
     * @allow (get, list) if false. Reports are not publicly accessible.
     * @allow (create) if isSignedIn(). Any authenticated user can create a report.
     * @allow (update, delete) if false. Reports cannot be updated or deleted by clients.
     * @principle Restricts read/write access to reports.
     */
    match /reports/{reportId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

   /**
     * @description Controls access to transactions.
     * @path /transactions/{transactionId}
     * @allow (get, list) if false. Transactions are not publicly accessible.
     * @allow (create) if isSignedIn() and the buyerId or sellerId in the request matches the user's UID.
     * @allow (update, delete) if false. Transactions cannot be updated or deleted by clients.
     * @principle Restricts read/write access to transactions.
     */
    match /transactions/{transactionId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
      allow update: if false;
      allow delete: if false;
    }
    /**
     * @description Controls access to admin roles.
     * @path /roles_admin/{userId}
     * @allow get: if false.
     * @allow list: if false.
     * @allow create: if true. // TODO: restrict to an admin role
     * @allow update: if false; // TODO: restrict to an admin role
     * @allow delete: if true; // TODO: restrict to an admin role
     */
     match /roles_admin/{userId} {
      function isAdmin() {
        return get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)).data.admin == true;
      }

      allow get: if false;
      allow list: if false;
      allow create: if request.auth.uid == userId; // Only the user themselves can create their admin role document.
      allow update: if false; // No updates allowed
      allow delete: if false; //No deletes allowed
    }
  }
}