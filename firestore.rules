/**
 * @fileOverview
 * Core Philosophy: This ruleset prioritizes authorization and access control based on user identity and explicit ownership or membership. It uses path-based ownership for user-specific data and membership maps for shared resources like chats.
 * Data Structure: The data is organized into top-level collections for Listings, Chats, Reviews, Events, CommunityFeed, Reports, and Transactions. User-specific data (User profiles) resides under /users/{userId}. Chat messages are stored in subcollections under /chats/{chatId}/messages/{messageId}.
 * Key Security Decisions:
 *  - User listing is implicitly disallowed.
 *  - Reads and writes are generally restricted to authenticated users.
 *  - Strict ownership is enforced for user profiles and associated resources.
 * Denormalization for Authorization:
 *  - Listings store `sellerId` to avoid needing to look up the seller's information during authorization checks.
 *  - Chats store a `participants` array to directly manage access control.
 * Structural Segregation:
 *  - Admin roles are stored in a separate `/roles_admin/{userId}` collection, allowing for efficient role-based access control without polluting user documents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows a user to read and write their own profile data.
     * @path /users/{userId}
     * @allow (create) request.auth.uid == 'user_abc' with data { id: 'user_abc', name: 'Test User' }
     * @allow (update) request.auth.uid == 'user_abc'
     * @deny (create) request.auth.uid != 'user_abc'
     * @deny (update) request.auth.uid != 'user_abc'
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == request.auth.uid;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.uid == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read listings, but restricts creating, updating, and deleting to the owner.
     * @path /listings/{listingId}
     * @allow (get, list) Everyone can read.
     * @allow (create) request.auth.uid == 'user_abc' with data.sellerId == request.auth.uid.
     * @allow (update, delete) request.auth.uid == resource.data.sellerId.
     * @deny (create) request.auth.uid != data.sellerId.
     * @deny (update, delete) request.auth.uid != resource.data.sellerId.
     * @principle Allows public reads with owner-only writes, validating relational integrity between documents.
     */
    match /listings/{listingId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.sellerId);
    }

    /**
     * @description Allows participants in a chat to read and write chat metadata. Only the participants of chat can read and write.
     * @path /chats/{chatId}
     * @allow (get, list) request.auth.uid is in resource.data.participants array.
     * @allow (create, update, delete) request.auth.uid is in resource.data.participants array.
     * @deny (get, list, create, update, delete) request.auth.uid is not in resource.data.participants array.
     * @principle Restricts access to shared chat resources based on a defined list of participants.
     */
    match /chats/{chatId} {
      allow get, list: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Allows participants in a chat to read and write chat messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) request.auth.uid is a participant in the chat.
     * @allow (create, update, delete) request.auth.uid is a participant in the chat and they are the message sender.
     * @deny (get, list, create, update, delete) request.auth.uid is not in the chat.
     * @principle Secures chat messages by verifying membership in the parent chat.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) && isExistingOwner(resource.data.senderId);
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) && isExistingOwner(resource.data.senderId);
    }

    /**
     * @description Allows anyone to read reviews, but only the buyer can create a review. The seller can neither update or delete the review.
     * @path /reviews/{reviewId}
     * @allow (get, list) Everyone can read reviews.
     * @allow (create) request.auth.uid == data.buyerId.
     * @deny (create) request.auth.uid != data.buyerId.
     * @deny (update, delete) No one can update or delete the review.
     * @principle Allows public reads with owner-only writes.
     */
    match /reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update, delete: if false;
    }

    /**
     * @description Allows anyone to read events, but only the organizer can create, update, and delete events.
     * @path /events/{eventId}
     * @allow (get, list) Everyone can read the event.
     * @allow (create, update, delete) Only the event creator can write to the event.
     * @deny (create, update, delete) Only the event creator can write to the event.
     * @principle Allows public reads with owner-only writes.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.organizerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.organizerId);
    }

    /**
     * @description Allows anyone to read community feed posts, but only the author can create, update, and delete posts.
     * @path /community_feed/{postId}
     * @allow (get, list) Everyone can read feed posts.
     * @allow (create, update, delete) Only the post creator can write to the post.
     * @deny (create, update, delete) Only the post creator can write to the post.
     * @principle Allows public reads with owner-only writes.
     */
    match /community_feed/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows authenticated users to create reports. No listing allowed. Only update and delete allowed for administrators.
     * @path /reports/{reportId}
     * @allow (create) Authenticated users can create a report.
     * @allow (update, delete) Only an admin can update or delete the report.
     * @deny (list) Listing is denied.
     * @principle Requires authentication for report creation, restricts modification to admins.
     */
    match /reports/{reportId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isAdmin() && resource != null;
      allow delete: if isSignedIn() && isAdmin() && resource != null;
    }

    /**
     * @description No read/write restriction, only allow listing. Transaction data can be accessed only if the user is buyer or seller in the transaction.
     * @path /transactions/{transactionId}
     *  @allow (get, list) if user is buyer or seller.
     *  @allow (create) if user is buyer or seller.
     *  @allow (update) if user is buyer or seller.
     *  @allow (delete) if user is buyer or seller.
     * @principle Restricts access to transaction records based on user involvement (buyer or seller).
     */
    match /transactions/{transactionId} {
      allow get, list: if isSignedIn() && (isBuyer(resource.data.buyerId) || isSeller(resource.data.sellerId));
      allow create: if isSignedIn() && (isBuyer(request.resource.data.buyerId) || isSeller(request.resource.data.sellerId));
      allow update: if isSignedIn() && (isBuyer(resource.data.buyerId) || isSeller(resource.data.sellerId));
      allow delete: if isSignedIn() && (isBuyer(resource.data.buyerId) || isSeller(resource.data.sellerId));
    }

    /**
     * @description Allows admins to perform any action on the admin role documents.
     * @path /roles_admin/{userId}
     * @allow (create, get, update, delete) if user is an administrator.
     * @deny (list) Listing is denied.
     * @principle Manages admin roles based on document existence in a dedicated collection.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn() && isAdmin();
      allow list: if false;
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
        return isSignedIn() && request.auth.uid == ownerId && resource != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isBuyer(buyerId) {
        return request.auth.uid == buyerId;
    }

    function isSeller(sellerId) {
        return request.auth.uid == sellerId;
    }
  }
}