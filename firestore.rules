/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strict authorization based on user identity and data ownership.
 * It uses path-based ownership for user-specific data and explicit membership lists for shared resources.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles, accessible only to the user themselves.
 * - /listings/{listingId}: Stores marketplace listings. Write access is restricted to the seller (owner). Publicly readable.
 * - /chats/{chatId}: Stores chat conversations. Access is controlled by an explicit list of participants stored in the document.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within a chat. Access inherits from the parent chat document.
 * - /reviews/{reviewId}: Stores reviews of sellers. Write access is restricted to the buyer who created the review.
 * - /events/{eventId}: Stores event information. Write access is restricted to the event organizer.
 * - /community_feed/{postId}: Stores community feed posts. Write access is restricted to the post author. Publicly readable.
 * - /reports/{reportId}: Stores reports of users or content. No write access is granted via rules.
 * - /transactions/{transactionId}: Stores transaction information.
 * - /roles_admin/{userId}: Stores admin roles. The existence of a document with the user's ID indicates admin privileges.
 *
 * Key Security Decisions:
 * - No user listing: Listing all users is explicitly denied to prevent information harvesting.
 * - Public read for listings and community feed: Read access is granted to all users.
 * - Ownership enforcement: Write access to user-specific data is strictly enforced based on the authenticated user's ID.
 * - Shared access control: Access to chats is controlled by explicit membership lists.
 *
 * Denormalization for Authorization:
 * - Listings include the `sellerId` to allow rules to validate ownership without `get()` calls.
 * - Chats include a `participants` array to explicitly define authorized users.
 * - Reviews include `sellerId` and `buyerId` to explicitly link users.
 *
 * Structural Segregation:
 * - User data and administrative data are stored in separate collections to simplify security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create) Signed-in user can create their own profile (if the UID matches).
     * @allow (get, list, update, delete) Signed-in user can only access their own profile.
     * @deny (create) Signed-in user cannot create a profile for another user.
     * @deny (get, list, update, delete) Signed-in user cannot access another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      //Allow the user to create their own document.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow update: if isSignedIn() && isOwner(userId) && request.auth.uid == userId;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to marketplace listings.
     * @path /listings/{listingId}
     * @allow (get, list) Any user can read listings.
     * @allow (create) Signed-in user can create a listing with their UID as the sellerId.
     * @allow (update, delete) Only the seller (owner) can update or delete a listing.
     * @deny (create) Signed-in user cannot create a listing with another user's UID as the sellerId.
     * @deny (update, delete) Another user cannot update or delete a listing.
     * @principle Enforces ownership for writes and allows public reads.
     */
    match /listings/{listingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.sellerId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner();
      allow delete: if isSignedIn() && isOwner();
    }

    /**
     * @description Controls access to chat conversations.
     * @path /chats/{chatId}
     * @allow (get, list) Only participants can read chat metadata.
     * @allow (create) Only participants can create a chat.
     * @allow (update, delete) Only participants can update or delete a chat.
     * @deny (get, list) Non-participants cannot access chat metadata.
     * @principle Enforces access based on explicit membership lists.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }

      function isCreatingParticipant() {
          return request.auth.uid in request.resource.data.participants;
      }

      allow get, list: if isSignedIn() && isParticipant();
      allow create: if isSignedIn() && isCreatingParticipant();
      allow update: if isSignedIn() && isParticipant();
      allow delete: if isSignedIn() && isParticipant();
    }

    /**
     * @description Controls access to messages within a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) Only participants of the parent chat can read messages.
     * @allow (create) Only participants of the parent chat can create messages.
     * @allow (update, delete) No one can update or delete messages (messages are immutable).
     * @deny (get, list) Non-participants cannot access messages.
     * @principle Enforces access based on parent chat membership.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isChatParticipant(chatId) {
        return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      }

      allow get, list: if isSignedIn() && isChatParticipant(chatId);
      allow create: if isSignedIn() && isChatParticipant(chatId);
      allow update, delete: if false;
    }

    /**
     * @description Controls access to reviews.
     * @path /reviews/{reviewId}
     * @allow (get, list) Any user can read reviews.
     * @allow (create) Signed-in user can create a review if their UID matches the buyerId.
     * @allow (update, delete) Only the buyer (owner) can update or delete their review, and the document exists.
     * @deny (create) Signed-in user cannot create a review with another user's UID as the buyerId.
     * @deny (update, delete) Another user cannot update or delete a review.
     * @principle Enforces ownership for writes and allows public reads.
     */
    match /reviews/{reviewId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.buyerId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner();
      allow delete: if isSignedIn() && isOwner();
    }

    /**
     * @description Controls access to events.
     * @path /events/{eventId}
     * @allow (get, list) Any user can read events.
     * @allow (create) Signed-in user can create an event if their UID matches the organizerId.
     * @allow (update, delete) Only the organizer can update or delete an event, and the document exists.
     * @deny (create) Signed-in user cannot create an event with another user's UID as the organizerId.
     * @deny (update, delete) Another user cannot update or delete an event.
     * @principle Enforces ownership for writes and allows public reads.
     */
    match /events/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.organizerId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner();
      allow delete: if isSignedIn() && isOwner();
    }

    /**
     * @description Controls access to community feed posts.
     * @path /community_feed/{postId}
     * @allow (get, list) Any user can read community feed posts.
     * @allow (create) Signed-in user can create a post if their UID matches the authorId.
     * @allow (update, delete) Only the author can update or delete a post, and the document exists.
     * @deny (create) Signed-in user cannot create a post with another user's UID as the authorId.
     * @deny (update, delete) Another user cannot update or delete a post.
     * @principle Enforces ownership for writes and allows public reads.
     */
    match /community_feed/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return request.auth.uid == resource.data.authorId;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner();
      allow delete: if isSignedIn() && isOwner();
    }

    /**
     * @description Controls access to reports.
     * @path /reports/{reportId}
     * @allow (get, list) Any user can read reports.
     * @deny (create, update, delete) No user can create, update, or delete reports through client.
     * @principle Restricts all write access to reports collection.
     */
    match /reports/{reportId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to transactions.
     * @path /transactions/{transactionId}
     * @allow (get, list) Any user can read transactions.
     * @deny (create, update, delete) No user can create, update, or delete transactions through client.
     * @principle Restricts all write access to transactions collection.
     */
    match /transactions/{transactionId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to admin roles.
     * @path /roles_admin/{userId}
     * @allow (get, list) Only admins can read admin roles.
     * @deny (create, update, delete) No user can create, update, or delete admin roles through client.
     */
    match /roles_admin/{userId} {
        function isSignedIn() {
          return request.auth != null;
        }
        function isAdmin() {
            return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
        }
        allow get, list: if isSignedIn() && isAdmin(); // Only admins can view the admin role collection
        allow create, update, delete: if false; // No client-side creation, update, or deletion of admin roles.
    }
  }
}