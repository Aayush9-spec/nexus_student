/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-layered security model for a student marketplace application, 
 * prioritizing user data protection and access control based on ownership and collaboration.
 *
 * Core Philosophy:
 *  - Strict user-ownership for personal data and resources they create.
 *  - Collaboration through explicitly defined shared access lists.
 *  - Segregation of user data from administrative roles.
 *
 * Data Structure:
 *  - User profiles are stored under `/users/{userId}`, accessible only to the user themselves.
 *  - Listings, reviews, events, and community feed posts are stored in top-level collections, 
 *    with access controlled by the associated `sellerId`, `organizerId`, or `authorId` field.
 *  - Chats are stored in the `/chats/{chatId}` collection, with access determined by the `participants` array.
 *  - Messages within a chat are stored in `/chats/{chatId}/messages/{messageId}`, with access inherited from the parent chat.
 *  - Administrative roles are managed via the `/roles_admin/{userId}` collection, where the existence of a document
 *    indicates admin privileges.
 *
 * Key Security Decisions:
 *  - User listing is disabled for privacy.
 *  - Administrative privileges are determined by the existence of a document in the `/roles_admin/{userId}` collection.
 *  - Strict validation of ownership on creation and immutability of ownership fields on updates.
 *
 * Denormalization for Authorization:
 *  - Listings store the `sellerId` to allow ownership checks without additional reads.
 *  - Chats store the `participants` array to define authorized users directly on the document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, allowing only the user to read and write their own data.
     * @path /users/{userId}
     * @allow (create, update, delete) if request.auth.uid == userId
     * @allow (get, list) if request.auth.uid == userId
     * @deny (create, update, delete) if request.auth.uid != userId
     * @deny (get, list) if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // No listing of users allowed for security reasons
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to listings, allowing anyone to read, but only the seller to modify.
     * @path /listings/{listingId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.sellerId
     * @allow (update, delete) if resource.data.sellerId == request.auth.uid
     * @deny (create) if request.auth.uid != request.resource.data.sellerId
     * @deny (update, delete) if resource.data.sellerId != request.auth.uid
     * @principle Allows public reads but enforces ownership for writes.
     */
    match /listings/{listingId} {
      function isOwner(sellerId) {
        return request.auth.uid == sellerId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isOwner(resource.data.sellerId);
    }

    /**
     * @description Manages access to chats, restricting read/write access to participants only.
     * @path /chats/{chatId}
     * @allow (get, list, create, update, delete) if request.auth.uid in resource.data.participants
     * @deny (get, list, create, update, delete) if request.auth.uid not in resource.data.participants
     * @principle Implements shared access control through a participants array.
     */
    match /chats/{chatId} {
      function isParticipant(participants) {
        return request.auth.uid in participants;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.participants.hasAny([request.auth.uid]); // Require the creator to be in the participants list
      allow update: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Secures messages within a chat, inheriting access from the parent chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list, create, update, delete) if request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
     * @deny (get, list, create, update, delete) if request.auth.uid not in get(/databases/$(database)/documents/chats/$(chatId)).data.participants
     * @principle Inherits access from the parent chat document's participants list.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isParticipant(chatId) {
        return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow update: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
    }

    /**
     * @description Manages access to reviews, allowing anyone to create, but only the seller or buyer can modify.
     * @path /reviews/{reviewId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.buyerId
     * @allow (update, delete) if resource.data.sellerId == request.auth.uid || resource.data.buyerId == request.auth.uid
     * @deny (create) if request.auth.uid != request.resource.data.buyerId
     * @deny (update, delete) if resource.data.sellerId != request.auth.uid && resource.data.buyerId != request.auth.uid
     * @principle Allows public reads but enforces ownership for writes by either the seller or the buyer.
     */
    match /reviews/{reviewId} {
      function isOwner(sellerId, buyerId) {
        return request.auth.uid == sellerId || request.auth.uid == buyerId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && (resource.data.sellerId == request.auth.uid || resource.data.buyerId == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.sellerId == request.auth.uid || resource.data.buyerId == request.auth.uid);
    }

    /**
     * @description Controls access to events, allowing anyone to read, but only the organizer to modify.
     * @path /events/{eventId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.organizerId
     * @allow (update, delete) if resource.data.organizerId == request.auth.uid
     * @deny (create) if request.auth.uid != request.resource.data.organizerId
     * @deny (update, delete) if resource.data.organizerId != request.auth.uid
     * @principle Allows public reads but enforces ownership for writes.
     */
    match /events/{eventId} {
      function isOwner(organizerId) {
        return request.auth.uid == organizerId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.organizerId);
      allow delete: if isSignedIn() && isOwner(resource.data.organizerId);
    }

    /**
     * @description Manages access to community feed posts, allowing anyone to read, but only the author to modify.
     * @path /community_feed/{postId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete) if resource.data.authorId == request.auth.uid
     * @deny (create) if request.auth.uid != request.resource.data.authorId
     * @deny (update, delete) if resource.data.authorId != request.auth.uid
     * @principle Allows public reads but enforces ownership for writes.
     */
    match /community_feed/{postId} {
      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isOwner(resource.data.authorId);
    }

    /**
     * @description Controls access to reports, restricting all access for now.
     * @path /reports/{reportId}
     * @allow create, get, list, update, delete: if false
     * @principle Restricts access to reports.
     */
    match /reports/{reportId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages access to transactions, restricting all access for now.
     * @path /transactions/{transactionId}
     * @allow create, get, list, update, delete: if false
     * @principle Restricts access to transactions.
     */
    match /transactions/{transactionId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages admin roles, allowing admins to perform privileged actions.
     * @path /roles_admin/{userId}
     * @allow create if request.auth.uid == userId
     * @allow get, delete if exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid))
     * @deny create if request.auth.uid != userId
     * @deny get, delete if !exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid))
     *
     * @principle Allows creation of admin roles only by matching user ID and validates existence for read/delete operations.
     */
        match /roles_admin/{userId} {
            function isAdmin() {
                return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
            }

            function isOwner(userId) {
              return request.auth.uid == userId;
            }

            allow get: if isAdmin();
            allow list: if false; // No listing of admins allowed for security reasons
            allow create: if isSignedIn() && isOwner(userId);
            allow update: if false; // Admin roles are managed by document existence, not data updates
            allow delete: if isAdmin() && isOwner(userId);
        }

  }
}