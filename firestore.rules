/**
 * @fileoverview Firestore Security Rules for the student marketplace application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strict authorization based on user identity and defined roles.
 * It leverages denormalization to avoid costly `get()` calls and improve performance.
 * Data validation is minimized in this prototyping phase, focusing on authorization-critical fields.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, secured with path-based ownership.
 * - /listings/{listingId}: Stores listings, with sellerId for ownership checks.
 * - /chats/{chatId}: Stores chat metadata, with participants array for access control.
 * - /chats/{chatId}/messages/{messageId}: Stores messages within a chat, access controlled by chat participants.
 * - /reviews/{reviewId}: Stores reviews, with sellerId and buyerId for access control.
 * - /events/{eventId}: Stores events, with organizerId for ownership checks.
 * - /community_feed/{postId}: Stores community feed posts, with authorId for ownership checks.
 * - /reports/{reportId}: Stores reports, access not restricted.
 * - /transactions/{transactionId}: Stores transaction data, with buyerId and sellerId for access control.
 * - /roles_admin/{userId}: Stores admin roles. Existence of a document indicates admin status.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy.
 * - Public read access is generally NOT granted unless explicitly required.
 * - Data validation is minimal, focusing on authorization and relational integrity.
 * - Admin roles are managed through a dedicated collection, allowing for simple existence checks.
 *
 * Denormalization for Authorization:
 * - Listings include the `sellerId` to allow ownership validation without extra reads.
 * - Chats include a `participants` array to define authorized users.
 * - Reviews include both `sellerId` and `buyerId` to define involved parties.
 * - Events include the `organizerId` to track event ownership.
 * - Community Feed includes the `authorId` to track post ownership.
 * - Transactions include `buyerId`, `sellerId`, and `listingId` to connect all entities.
 *
 * Structural Segregation:
 * - User profiles and admin roles are stored in separate collections to clearly differentiate access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their profile.
     * @allow (get, update, delete) Authenticated user can read/write their own profile.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @deny (get, update, delete) Other users cannot read/write this profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId) && request.auth.uid == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages listings.  Anyone can read a listing, but only the seller can modify or delete it.
     * @path /listings/{listingId}
     * @allow (get, list) Anyone can read/list listings.
     * @allow (create) Seller with matching sellerId can create a listing.
     * @allow (update, delete) Seller with matching sellerId can update/delete their listing.
     * @deny (create) User cannot create a listing with a mismatched sellerId.
     * @deny (update, delete) Other users cannot update/delete this listing.
     * @principle Allows public read with owner-only writes.
     */
    match /listings/{listingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(sellerId) {
        return request.auth.uid == sellerId;
      }

      function isExistingOwner(sellerId) {
        return isOwner(sellerId) && resource.data != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isOwner(resource.data.sellerId);
    }

    /**
     * @description Manages chats. Only participants can read/write chat metadata.
     * @path /chats/{chatId}
     * @allow (get, list) Participants can read/list chat metadata.
     * @allow (create) Users can create a chat with themselves as participants.
     * @allow (update, delete) Only participants can update/delete the chat (e.g., modifying participants).
     * @deny (get, list) Non-participants cannot access chat metadata.
     * @deny (create) User cannot create a chat without being a participant.
     * @deny (update, delete) Non-participants cannot modify the chat.
     * @principle Enforces shared access between collaborators.
     */
    match /chats/{chatId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return isSignedIn() && resource.data.participants.hasAny([request.auth.uid]);
      }

      function isExistingParticipant() {
        return isSignedIn() && resource.data.participants.hasAny([request.auth.uid]) && resource.data != null;
      }

      function canCreateChat() {
        return isSignedIn() && request.resource.data.participants.hasAll([request.auth.uid]);
      }

      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.participants.hasAll([request.auth.uid]);
      allow update: if isExistingParticipant();
      allow delete: if isExistingParticipant();
    }

    /**
     * @description Manages messages within a chat. Only participants of the chat can read/write messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) Participants of the chat can read/list messages.
     * @allow (create) Participants of the chat can create messages.
     * @allow (update, delete) No direct updating or deleting of messages.
     * @deny (get, list) Non-participants cannot access messages.
     * @deny (create) Non-participants cannot send messages.
     * @deny (update, delete) Direct updates and deletes are not allowed.
     * @principle Enforces shared access between collaborators for subcollections.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

     function isChatParticipant(chatId) {
        return isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      }

      allow get, list: if isChatParticipant(chatId);
      allow create: if isChatParticipant(chatId);
      allow update, delete: if false;
    }

    /**
     * @description Manages reviews.  Anyone can read a review, but only the buyer or seller can modify or delete it.
     * @path /reviews/{reviewId}
     * @allow (get, list) Anyone can read/list reviews.
     * @allow (create) Buyer with matching buyerId can create a review.
     * @allow (update, delete) Buyer with matching buyerId can update/delete their review.
     * @deny (create) User cannot create a review with a mismatched buyerId.
     * @deny (update, delete) Other users cannot update/delete this review.
     * @principle Allows public read with owner-only writes.
     */
    match /reviews/{reviewId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(reviewId) {
        return request.auth.uid == resource.data.buyerId;
      }

      function isExistingOwner(reviewId) {
        return isOwner(reviewId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(reviewId);
      allow delete: if isSignedIn() && isOwner(reviewId);
    }

    /**
     * @description Manages events. Anyone can read an event, but only the organizer can modify or delete it.
     * @path /events/{eventId}
     * @allow (get, list) Anyone can read/list events.
     * @allow (create) Organizer with matching organizerId can create an event.
     * @allow (update, delete) Organizer with matching organizerId can update/delete their event.
     * @deny (create) User cannot create an event with a mismatched organizerId.
     * @deny (update, delete) Other users cannot update/delete this event.
     * @principle Allows public read with owner-only writes.
     */
    match /events/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(eventId) {
        return request.auth.uid == resource.data.organizerId;
      }

      function isExistingOwner(eventId) {
        return isOwner(eventId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(eventId);
      allow delete: if isSignedIn() && isOwner(eventId);
    }

    /**
     * @description Manages community feed posts. Anyone can read a post, but only the author can modify or delete it.
     * @path /community_feed/{postId}
     * @allow (get, list) Anyone can read/list community feed posts.
     * @allow (create) Author with matching authorId can create a post.
     * @allow (update, delete) Author with matching authorId can update/delete their post.
     * @deny (create) User cannot create a post with a mismatched authorId.
     * @deny (update, delete) Other users cannot update/delete this post.
     * @principle Allows public read with owner-only writes.
     */
    match /community_feed/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(postId) {
        return request.auth.uid == resource.data.authorId;
      }

      function isExistingOwner(postId) {
        return isOwner(postId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(postId);
      allow delete: if isSignedIn() && isOwner(postId);
    }

    /**
     * @description Manages reports.  Anyone can create a report. No restrictions on reading, updating, or deleting.
     * @path /reports/{reportId}
     * @allow (get, list, create, update, delete) No restrictions.
     * @principle Open access for all operations.
     */
    match /reports/{reportId} {
      allow get, list, create, update, delete: if true;
    }

    /**
     * @description Manages transactions. Anyone can read transaction information, but only the buyer or seller can modify or delete it.
     * @path /transactions/{transactionId}
     * @allow (get, list) Anyone can read/list transactions.
     * @allow (create) Buyer or Seller can create a transaction related to them.
     * @allow (update, delete) No direct updating or deleting of transactions.
     * @deny (create) User cannot create a transaction where they are not the buyer or seller.
     * @deny (update, delete) Direct updates and deletes are not allowed.
     * @principle Restricts write access to involved parties.
     */
    match /transactions/{transactionId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isBuyerOrSeller(transactionId) {
            return isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
        }

        allow get, list: if true;
        allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
        allow update, delete: if false;
    }

    /**
     * @description Manages admin roles. Only an admin user can create, update, or delete an admin role.
     * @path /roles_admin/{userId}
     * @allow (get) Anyone can get admin roles.
     * @allow (list) Listing admin roles is not permitted.
     * @allow (create) Authenticated user can create their admin role.
     * @allow (update, delete) Authenticated user can update/delete their admin role.
     * @deny (create) User cannot create an admin role with a mismatched UID.
     * @deny (update, delete) Other users cannot update/delete this admin role.
     * @principle Enforces document existence for admin roles.
     */
    match /roles_admin/{userId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isAdmin(userId) {
          return request.auth.uid == userId;
        }

        function isExistingAdmin(userId) {
          return isAdmin(userId) && resource.data != null;
        }
        allow get: if true;
        allow list: if false;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if isSignedIn() && request.auth.uid == userId;
        allow delete: if isExistingAdmin(userId);
    }
  }
}